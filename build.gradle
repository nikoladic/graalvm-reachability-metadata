buildscript {
    dependencies {
        classpath('org.codehaus.groovy:groovy-all:3.0.10')
    }
}

plugins {
    id "com.diffplug.spotless" version "6.3.0"
}

allprojects {
    repositories {
        mavenCentral()
    }
}

group = "metadata-tests"

spotless {
    json {
        target('metadata/**/*.json')
        target('tests/**/*.json')
        targetExclude('tests/**/build/**/*.json')
        gson()
                .indentWithSpaces(2)
                .sortByKeys()
                .version("2.9.0")
    }
}


import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Path
import java.util.stream.Collectors
import java.util.stream.Stream

class TestLogic {
    /**
     * Given path to a JSON file return its parsed content
     *
     * @param jsonPath path to a JSON file
     * @return parsed contents
     */
    static Object extractJsonFile(Path jsonPath) {
        return new JsonSlurper().parseText(jsonPath.toFile().text)
    }

    /**
     * Splits maven coordinates into group ID, artifact ID and version.
     * If some part of coordinate is missing, return null instead.
     *
     * @param coordinates maven coordinate
     * @return list containing groupId, artifactId and version (or null values if missing)
     */
    static List<String> splitCoordinates(String coordinates) {
        List<String> parts = coordinates.split(':').toList()
        parts.addAll((List<String>) [null] * 3) // Maven coordinates consist of 3 parts

        if (parts[0] == "" || parts[0] == "all" || parts[0] == "any") {
            parts[0] = null
        }
        return parts[0..2]
    }

    /**
     * Checks if given coordinates string matches given group ID and artifact ID.
     * null values match every possible value (null artifact ID matches all artifacts in given group).
     *
     * @param coordinates maven coordinate
     * @param groupId group ID to match
     * @param artifactId artifact ID to match
     * @return boolean if coordinates matches said group ID / artifact ID combo
     */
    static boolean coordinatesMatch(String coordinates, String groupId, String artifactId) {
        def (String testGroup, String testArtifact) = splitCoordinates(coordinates)
        if (groupId != testGroup && groupId != null) {
            return false
        }
        if (artifactId != testArtifact && artifactId != null) {
            return false
        }
        return true
    }

    /**
     * Returns all libraries that are specified in index.json file from metadata directory.
     *
     * @return list of all library definitions
     */
    static List<Map<String, ?>> getAllLibrariesIndex(Path metadataDir) {
        return (List<Map<String, ?>>) extractJsonFile(metadataDir.resolve('index.json'))
    }

    /**
     * Returns a set of all directories that match given group ID and artifact ID.
     * null values match every possible value (null artifact ID matches all artifacts in given group).
     *
     * @return set of all directories that match given criteria
     */
    static Set<String> getMatchingDirs(Path metadataRoot, String groupId, String artifactId) {
        Set<String> dirs = new HashSet<String>()
        for (Map<String, ?> library in getAllLibrariesIndex(metadataRoot)) {
            if (coordinatesMatch((String) library["module"], groupId, artifactId)) {
                if (library.containsKey("directory")) {
                    dirs.add((String) library["directory"])
                }
                if (library.containsKey("requires")) {
                    for (String dep in library["requires"]) {
                        def (String depGroup, String depArtifact) = splitCoordinates((String) dep)
                        dirs.addAll(getMatchingDirs(metadataRoot, depGroup, depArtifact))
                    }
                }
            }
        }

        if (groupId != null && artifactId != null) {
            Path defaultDir = metadataRoot.resolve(groupId.replace(".", "/")).resolve(artifactId)
            if (defaultDir.resolve("index.json").toFile().exists()) {
                dirs.add(defaultDir.toString())
            }
        }
        return dirs
    }

    /**
     * Generates a list of all test invocations that match given group ID, artifact ID and version combination.
     * null values match every possible value (null artifact ID matches all artifacts in given group).
     *
     * @param groupId group ID to match
     * @param artifactId artifact ID to match
     * @param version version to match
     * @return list in which every entry holds complete information required to perform a single test invocation
     */
    static List<Map<String, ?>> generateTestInvocations(Path metadataRoot, Path testRoot, String groupId, String artifactId, String version) {
        List<Map<String, ?>> invocations = new ArrayList<>()

        Set<String> matchingDirs = getMatchingDirs(metadataRoot, groupId, artifactId)
        for (String directory in matchingDirs) {
            Path fullDir = metadataRoot.resolve(directory)
            Path index = fullDir.resolve("index.json")
            def data = extractJsonFile(index)

            for (def library in data) {
                if (coordinatesMatch((String) library["module"], groupId, artifactId)) {
                    Path metadataDir = fullDir.resolve((String) library["metadata-version"])


                    Path testDir = testRoot.resolve((String) library["test-directory"])
                    Path testIndexPath = testDir.resolve("index.json")
                    def tests = extractJsonFile(testIndexPath)
                    List<String> cmd
                    if (tests["test-command"] instanceof String) {
                        cmd = tests["test-command"].split(" ")
                    } else {
                        cmd = tests["test-command"]
                    }

                    Map<String, String> env = null
                    if (tests.hasProperty("test-environment")) {
                        env = (Map<String, String>) tests["test-environment"]
                    }

                    for (String tested in library["tested-versions"]) {
                        if (version == null || tested == version) {
                            String coordinates = library["module"] + ":" + tested
                            def (String libraryGroup, String libraryArtifact, String libraryVersion) = splitCoordinates(coordinates)
                            List<String> versionCmd = cmd.stream()
                                    .map((String c) -> processCommand(c, metadataDir,
                                            libraryGroup, libraryArtifact, libraryVersion))
                                    .collect(Collectors.toList())

                            invocations.add(["coordinates"       : coordinates,
                                             "library-version"   : libraryVersion,
                                             "metadata-directory": metadataDir,
                                             "test-directory"    : testDir,
                                             "test-command"      : versionCmd,
                                             "test-environment"  : env])
                        }
                    }
                }
            }
        }
        invocations = invocations.unique()
        return invocations
    }

    /**
     * Returns a list of metadata files in a given directory.
     *
     * @param directory
     * @return list of json files contained in it
     */
    static List<String> getMetadataFileList(Path directory) {
        List<String> foundFiles = new ArrayList<>()
        try (Stream<Path> paths = Files.walk(directory)) {
            paths.filter(Files::isRegularFile)
                    .map(p -> p.fileName.toString())
                    .filter(s -> s.endsWith(".json"))
                    .filter(s -> !s.endsWith("index.json"))
                    .forEach(s -> foundFiles.add(s))
        }
        Path indexFile = directory.resolve("index.json")
        if (indexFile.toFile().exists()) {
            List<String> indexFiles = extractJsonFile(indexFile)
            assert indexFiles.toSet() == foundFiles.toSet(), String.format("Metadata file list in '%s' is not up to date!", indexFile.toAbsolutePath())
            return indexFiles
        } else {
            return foundFiles
        }
    }

    /**
     * Fills in template parameters in the command invocation.
     * Parameters are defined as <param_name> in cmd.
     *
     * @param cmd command line with parameters
     * @param metadataDir metadata directory location
     * @param groupId group ID
     * @param artifactId artifact ID
     * @param version version
     * @return final command
     */
    static String processCommand(String cmd, Path metadataDir, String groupId, String artifactId, String version) {
        return cmd.replace("<metadata_dir>", metadataDir.toAbsolutePath().toString())
                .replace("<group_id>", groupId)
                .replace("<artifact_id>", artifactId)
                .replace("<version>", version)
    }

    /**
     * Returns a list of test invocations that matches changed files between base and new commit.
     * @param baseCommit
     * @param newCommit
     * @param rootDir
     * @return List of test invocations
     */
    static List<Map<String, ?>> diffTestInvocations(String baseCommit, String newCommit, Path rootDir) {
        String cmd = String.format("git diff --name-only --diff-filter=ACMRT %s %s",
                baseCommit,
                newCommit)

        Process p = cmd.execute()
        String output = p.in.text
        List<String> diffFiles = Arrays.asList(output.split("\\r?\\n"))
        Set<Path> changedTests = new HashSet<String>()
        Set<Path> changedMetadata = new HashSet<String>()

        for (String line in diffFiles) {
            Path dirAbspath = rootDir.resolve(line)
            if (line.startsWith("tests/")) {
                changedTests.add(dirAbspath)
            } else if (line.startsWith("metadata/")) {
                changedMetadata.add(dirAbspath)
            }
        }

        List<Map<String, ?>> invocations
        invocations = TestLogic.generateTestInvocations(rootDir.resolve("metadata"),
                rootDir.resolve("tests"), null, null, null)

        Set<Map<String, ?>> matchingInvocations = new HashSet<>()
        for (Map<String, ?> inv in invocations) {
            boolean added = false

            for (Path metadata in changedMetadata) {
                if (metadata.startsWith(inv["metadata-directory"])) {
                    matchingInvocations.add(inv)
                    added = true
                }
            }

            if (added) {
                continue
            }

            for (Path test in changedTests) {
                if (test.startsWith(inv["test-directory"])) {
                    matchingInvocations.add(inv)
                }
            }
        }
        return matchingInvocations.toList()
    }
}

/**
 * Creates a task that executes test invocation
 * @param inv
 * @returns Task that executes said invocation
 */
Task invocationToTask(Map<String, ?> inv) {
    List<String> cmd = inv["test-command"]
    Path metadataDir = inv["metadata-directory"]
    Path testDir = inv["test-directory"]

    Map<String, String> env = new HashMap<>(System.getenv())
    if (inv.containsKey("test-environment") && inv["test-environment"] != null) {
        env.putAll((Map<String, String>) inv["test-environment"])
    }

    String taskName = "test-" + inv["coordinates"].replace(":", "-")

    def existing = getProject().getTasksByName(taskName, true)
    if (!existing.isEmpty()) {
        // We already added this task, so lets just return it.
        return existing.iterator().next()
    }

    Task testTask

    if (cmd.get(0) == "gradle" || cmd.get(0) == "./gradlew") {
        // This is a gradle project so lets use GradleBuild to avoid running new Gradle process.
        cmd.remove(0)

        List<String> taskList = cmd.stream()
                .filter(arg -> !arg.startsWith("-"))
                .collect(Collectors.toList())

        Map<String, String> projectProperties = new HashMap()
        projectProperties.put("metadata.dir", metadataDir.toString())
        projectProperties.put("library.version", inv["library-version"])

        projectProperties.putAll(cmd.stream()
                .filter(arg -> arg.startsWith("-P"))
                .map(s -> s.split("-P", 2)[1])
                .map(s -> s.split("=", 2))
                .collect(Collectors.toMap(s -> s[0], s -> s[1]))
        )

        testTask = tasks.register(taskName, GradleBuild) { task ->
            task.dependsOn("spotlessJsonCheck")
            task.setBuildName(inv["coordinates"])
            task.setDir(testDir)
            task.setTasks(taskList)
            task.startParameter.projectProperties.putAll(projectProperties)
            task.getInputs().dir(metadataDir)
            task.getInputs().files(TestLogic.getMetadataFileList(metadataDir))
            task.getOutputs()
        }.get()
    } else {
        testTask = tasks.register(taskName, Exec) { task ->
            task.dependsOn("spotlessJsonCheck")
            task.commandLine(cmd)
            task.workingDir(testDir.toFile())
            task.environment(env)
            task.getInputs().dir(metadataDir)
            task.getInputs().files(TestLogic.getMetadataFileList(metadataDir))
            task.getInputs().dir(testDir)

            task.ignoreExitValue(true)

            task.doLast(() -> {
                int exitCode = task.getExecutionResult().get().getExitValue()
                if (exitCode != 0) {
                    String msg = String.format("Test for %s failed with exit code %d.", inv["coordinates"], exitCode)
                    throw new GradleException(msg)
                } else {
                    logger.lifecycle("Test for {} passed.", inv["coordinates"])
                    logger.lifecycle("====================")
                }
            })
        }.get()
    }

    testTask.doFirst(() -> {
        logger.lifecycle("====================")
        logger.lifecycle("Testing library: {}", inv["coordinates"])
        logger.lifecycle("Command: {}", String.join(" ", cmd))
        logger.lifecycle("Executing test...")
    })
    return testTask
}

Path rootDir = getProject().getProjectDir().toPath()
Path metadataRoot = rootDir.resolve("metadata")
Path testRoot = rootDir.resolve("tests")

String coordinates = Objects.requireNonNullElse(project.findProperty("coordinates"), "")
def (String groupId, String artifactId, String version) = TestLogic.splitCoordinates(coordinates)


// gradle check
tasks.register('check', DefaultTask) { task ->
    task.setDescription("Alias for 'spotlessJsonCheck'")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
    task.dependsOn("spotlessJsonCheck")
}


// gradle test -Pcoordinates=<maven-coordinates>
Task test = tasks.register('test', DefaultTask) { task ->
    task.setDescription("Tests JVM Reflection Metadata that matches given coordinates")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}.get()

for (Map<String, ?> inv in TestLogic.generateTestInvocations(metadataRoot, testRoot, groupId, artifactId, version)) {
    Task task = invocationToTask(inv)
    test.dependsOn(task)
}


// gradle diff -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
Task diff = tasks.register('diff', DefaultTask) { task ->
    task.setDescription("Tests JVM Reflection Metadata that was changed between 'baseCommit' and 'newCommit'")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}.get()

if (project.hasProperty("baseCommit")) {
    String baseCommit = project.findProperty("baseCommit")
    String newCommit = Objects.requireNonNullElse(project.findProperty("newCommit"), "HEAD")
    for (def inv in TestLogic.diffTestInvocations(baseCommit, newCommit, project.getRootDir().toPath())) {
        Task task = invocationToTask(inv)
        diff.dependsOn(task)
    }
} else {
    diff.doFirst(() -> {
        throw new GradleException("Missing 'baseCommit' property! Rerun Gradle with '-PbaseCommit=<commit-hash>'")
    })
}


// gradle package
tasks.register('package', Zip) { task ->
    task.setDescription("Packages current repository to 'build/repository.zip'")
    task.setGroup(PublishingPlugin.PUBLISH_TASK_GROUP)
    task.archiveFileName = "repository.zip"
    task.destinationDirectory = layout.buildDirectory
    from(layout.projectDirectory.dir("metadata"))
}
