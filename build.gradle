buildscript {
    dependencies {
        classpath('org.codehaus.groovy:groovy-all:3.0.10')
    }
}

plugins {
    id "com.diffplug.spotless" version "6.3.0"
}

allprojects {
    repositories {
        mavenCentral()
    }
}

spotless {
    json {
        target('metadata/**/*.json')
        target('tests/**/*.json')
        targetExclude('tests/**/build/**/*.json')
        gson()
                .indentWithSpaces(2)
                .sortByKeys()
                .version("2.9.0")
    }
}


import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Path
import java.util.stream.Stream
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

class TestLogic {
    final Path METADATA_ROOT
    final Path TEST_ROOT
    final Logger logger

    TestLogic(Path metadataDir, Path testDir, Logger logger) {
        this.METADATA_ROOT = metadataDir
        this.TEST_ROOT = testDir
        this.logger = logger
    }

    /**
     * For path to a JSON file return its parsed content
     *
     * @param jsonPath path to a JSON file
     * @return parsed contents
     */
    static Object extractJsonFile(Path jsonPath) {
        return new JsonSlurper().parseText(jsonPath.toFile().text)
    }

    /**
     * Splits maven coordinates into group ID, artifact ID and version.
     * If some part of coordinate is missing, return null instead.
     *
     * @param coordinates maven coordinate
     * @return list containing groupId, artifactId and version (or null values if missing)
     */
    static List<String> splitCoordinates(String coordinates) {
        List<String> parts = coordinates.split(':').toList()
        parts.addAll((List<String>) [null] * 3) // Maven coordinates consist of 3 parts

        if (parts[0] == "" || parts[0] == "all" || parts[0] == "any") {
            parts[0] = null
        }
        return parts[0..2]
    }

    /**
     * Checks if given coordinates string matches given group ID and artifact ID.
     * null values match every possible value (null artifact ID matches all artifacts in given group).
     *
     * @param coordinates maven coordinate
     * @param groupId group ID to match
     * @param artifactId artifact ID to match
     * @return boolean if coordinates matches said group ID / artifact ID combo
     */
    static boolean coordinatesMatch(String coordinates, String groupId, String artifactId) {
        def (String testGroup, String testArtifact) = splitCoordinates(coordinates)
        if (groupId != testGroup && groupId != null) {
            return false
        }
        if (artifactId != testArtifact && artifactId != null) {
            return false
        }
        return true
    }

    /**
     * Returns all libraries that are specified in index.json file from metadata directory.
     *
     * @return list of all library definitions
     */
    List<Map<String, ?>> getAllLibrariesIndex() {
        return (List<Map<String, ?>>) extractJsonFile(METADATA_ROOT.resolve('index.json'))
    }

    /**
     * Returns a set of all directories that match given group ID and artifact ID.
     * null values match every possible value (null artifact ID matches all artifacts in given group).
     *
     * @return set of all directories that match given criteria
     */
    Set<String> getMatchingDirs(String groupId, String artifactId) {
        Set<String> dirs = new HashSet<String>()
        for (Map<String, ?> library in getAllLibrariesIndex()) {
            if (coordinatesMatch((String) library["module"], groupId, artifactId)) {
                if (library.containsKey("directory")) {
                    dirs.add((String) library["directory"])
                }
                if (library.containsKey("requires")) {
                    for (String dep in library["requires"]) {
                        def (String depGroup, String depArtifact) = splitCoordinates((String) dep)
                        dirs.addAll(getMatchingDirs(depGroup, depArtifact))
                    }
                }
            }
        }

        if (groupId != null && artifactId != null) {
            Path defaultDir = METADATA_ROOT.resolve(groupId.replace(".", "/")).resolve(artifactId)
            if (defaultDir.resolve("index.json").toFile().exists()) {
                dirs.add(defaultDir.toString())
            }
        }
        return dirs
    }

    /**
     * Generates a list of all test invocations that match given group ID, artifact ID and version combination.
     * null values match every possible value (null artifact ID matches all artifacts in given group).
     *
     * @param groupId group ID to match
     * @param artifactId artifact ID to match
     * @param version version to match
     * @return list in which every entry holds complete information required to perform a single test invocation
     */
    List<Map<String, ?>> generateTestInvocations(String groupId, String artifactId, String version) {
        List<Map<String, ?>> invocations = new ArrayList<>()

        Set<String> matchingDirs = getMatchingDirs(groupId, artifactId)
        for (String directory in matchingDirs) {
            Path fullDir = METADATA_ROOT.resolve(directory)
            Path index = fullDir.resolve("index.json")
            def data = extractJsonFile(index)

            for (def library in data) {
                if (coordinatesMatch((String) library["module"], groupId, artifactId)) {
                    Path metadataDir = fullDir.resolve((String) library["metadata-version"])

                    Path testIndexPath = TEST_ROOT.resolve((String) library["test-directory"]).resolve("index.json")
                    def tests = extractJsonFile(testIndexPath)
                    List<String> cmd
                    if (tests["test-command"] instanceof String) {
                        cmd = tests["test-command"].split(" ")
                    } else {
                        cmd = tests["test-command"]
                    }
                    Map<String, String> env = null
                    if (tests.hasProperty("test-environment")) {
                        env = (Map<String, String>) tests["test-environment"]
                    }

                    for (String tested in library["tested-versions"]) {
                        if (version == null || tested == version) {
                            String coordinates = library["module"] + ":" + tested
                            invocations.add(["coordinates"       : coordinates,
                                             "metadata-directory": metadataDir,
                                             "test-directory"    : library["test-directory"],
                                             "test-command"      : cmd,
                                             "test-environment"  : env])
                        }
                    }
                }
            }
        }
        invocations = invocations.unique()
        return invocations
    }

    /**
     * Returns a list of metadata files in a given directory.
     *
     * @param directory
     * @return list of json files contained in it
     */
    static List<String> getMetadataFileList(Path directory) {
        Path indexFile = directory.resolve("index.json")
        if (indexFile.toFile().exists()) {
            return (List<String>) extractJsonFile(indexFile)
        } else {
            List<String> ret = new ArrayList<>()
            try (Stream<Path> paths = Files.walk(directory)) {
                paths.filter(Files::isRegularFile)
                        .map(p -> p.fileName.toString())
                        .filter(s -> s.endsWith(".json"))
                        .forEach(s -> ret.add(s))
            }
            return ret
        }
    }

    /**
     * Creates a jar file that contains all metadata from given directory.
     *
     * @param metadataDir directory where metadata is located
     * @param outputDir directory where jar file should be created
     * @param groupId group ID of artifact that is being tested
     * @param artifactId artifact ID of artifact that is being tested
     * @param version version of artifact that is being tested
     * @return path to a jar file that contains metadata
     */
    static Path packageMetadataJar(Path metadataDir, Path outputDir, String groupId, String artifactId, String version) {
        List<String> files = getMetadataFileList(metadataDir)
        String filename = groupId + "." + artifactId + "." + version + ".jar"
        Path outputFile = outputDir.resolve(filename)

        try (ZipOutputStream zipFile = new ZipOutputStream(new FileOutputStream(outputFile.toFile()))) {
            for (String file in files) {
                Path filePath = metadataDir.resolve(file)
                String zipName = "META-INF/native-image/" + groupId + "/" + artifactId + "/" + file
                try (FileInputStream inputStream = new FileInputStream(filePath.toFile())) {
                    ZipEntry entry = new ZipEntry(zipName)
                    zipFile.putNextEntry(entry)

                    byte[] readBuffer = new byte[2048]
                    for (int read; (read = inputStream.read(readBuffer)) > 0;) {
                        zipFile.write(readBuffer, 0, read)
                    }
                }
            }
        }
        return outputFile
    }

    /**
     * Fills in template parameters in the command invocation.
     * Parameters are defined as <param_name> in cmd.
     *
     * @param cmd command line with parameters
     * @param metadataDir metadata directory location
     * @param jarFile jar file location
     * @param groupId group ID
     * @param artifactId artifact ID
     * @param version version
     * @return final command
     */
    static String processCommand(String cmd, Path metadataDir, Path jarFile, String groupId, String artifactId, String version) {
        return cmd.replace("<metadata_dir>", metadataDir.toAbsolutePath().toString())
                .replace("<jar_file>", jarFile.toAbsolutePath().toString())
                .replace("<group_id>", groupId)
                .replace("<artifact_id>", artifactId)
                .replace("<version>", version)
    }

    /**
     * Runs test invocations sequentially.
     * Terminates the process with error code if test wasn't successful.
     *
     * @param invocations all test invocations that should be executed
     */
    void runInvocations(List<Map<String, ?>> invocations) {
        Path tempDir = Files.createTempDirectory("InvocationRun")
        try {
            for (def inv in invocations) {
                def (String groupId, String artifactId, String version) = splitCoordinates((String) inv["coordinates"])
                Path jarFile = packageMetadataJar((Path) inv["metadata-directory"], tempDir, groupId, artifactId, version)
                try {
                    logger.lifecycle("====================")
                    logger.lifecycle("Testing library: {}", inv["coordinates"])

                    List<String> cmd = List.of(inv["test-command"].stream()
                            .map((String s) -> processCommand(s, (Path) inv["metadata-directory"],
                                    jarFile, groupId, artifactId, version)).toArray())
                    logger.lifecycle("Command: {}", String.join(" ", cmd))

                    Map<String, String> env = new HashMap<>(System.getenv())
                    if (inv.containsKey("test-environment") && inv["test-environment"] != null) {
                        env.putAll((Map<String, String>) inv["test-environment"])
                    }

                    Path testDirectory = TEST_ROOT.resolve((String) inv["test-directory"])

                    logger.lifecycle("Executing test...")
                    ProcessBuilder pb = new ProcessBuilder()
                    pb.command(cmd)
                    pb.directory(testDirectory.toFile())
                    pb.environment().putAll(env)

                    Process p = pb.start()
                    p.consumeProcessOutput(System.out, System.err)
                    int exitCode = p.waitFor()
                    if (exitCode != 0) {
                        logger.error("Test for {} failed with exit code {}.",
                                (String) inv["coordinates"], exitCode)
                        System.exit(exitCode)
                    } else {
                        logger.lifecycle("Test for {} passed.", inv["coordinates"])
                    }
                } finally {
                    logger.lifecycle("====================")
                }
            }
        } finally {
            Files.walk(tempDir)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete)
        }

    }

    @SuppressWarnings("unused")
    void runTests(String coordinates) {
        def (String groupId, String artifactId, String version) = splitCoordinates(coordinates)

        List<Map<String, ?>> invocations = generateTestInvocations(groupId, artifactId, version)
        runInvocations(invocations)
    }
}

abstract class AbstractMetadataTestTask extends DefaultTask {
    @Input
    abstract Property<Path> getMetadataDir()

    @Input
    abstract Property<Path> getTestDir()

    @Input
    abstract Property<TestLogic> getHandler()

    AbstractMetadataTestTask() {
        this.dependsOn("spotlessJsonCheck")
        this.setGroup(JavaBasePlugin.VERIFICATION_GROUP)

        Path rootDir = getProject().getProjectDir().toPath()
        metadataDir.convention(rootDir.resolve("metadata"))
        testDir.convention(rootDir.resolve("tests"))

        handler.convention(new TestLogic(metadataDir.get(), testDir.get(), getProject().getLogger()))
    }
}

abstract class MetadataTestTask extends AbstractMetadataTestTask {
    @Input
    abstract Property<String> getCoordinates()

    MetadataTestTask() {
        coordinates.convention("")
        inputs.dir(metadataDir.get())
        inputs.dir(testDir.get())
    }

    @TaskAction
    def test() {
        handler.get().runTests(coordinates.get())
    }
}

abstract class DiffMetadataTestTask extends AbstractMetadataTestTask {
    @Input
    abstract Property<String> getBaseCommit()

    @Input
    abstract Property<String> getNewCommit()

    DiffMetadataTestTask() {
        newCommit.convention("HEAD")
    }

    @TaskAction
    def diff() {
        String cmd = String.format("git diff --name-only --diff-filter=ACMRT %s %s",
                baseCommit.get(),
                newCommit.get())

        Process p = cmd.execute()
        String output = p.in.text
        List<String> diffFiles = Arrays.asList(output.split("\\r?\\n"))
        Set<Path> changedTests = new HashSet<String>()
        Set<Path> changedMetadata = new HashSet<String>()

        for (String line in diffFiles) {
            Path dirAbspath = rootDir.get().resolve(line)
            if (line.startsWith("tests/")) {
                changedTests.add(dirAbspath)
            } else if (line.startsWith("metadata/")) {
                changedMetadata.add(dirAbspath)
            }
        }

        List<Map<String, ?>> invocations = handler.get().generateTestInvocations(null, null, null)

        Set<String> matchingCoordinates = new HashSet<String>()
        for (Map<String, ?> inv in invocations) {
            boolean added = false

            for (Path metadata in changedMetadata) {
                if (metadata.startsWith(inv["metadata-directory"])) {
                    matchingCoordinates.add(inv["coordinates"])
                    added = true
                }
            }

            if (added) {
                continue
            }

            for (Path test in changedTests) {
                if (test.startsWith(inv["test-directory"])) {
                    matchingCoordinates.add(inv["coordinates"])
                }
            }
        }

        for (String coordinate in matchingCoordinates) {
            handler.get().runTests(coordinate)
        }
    }
}

tasks.register('check', DefaultTask) { task ->
    task.setDescription("Alias for 'spotlessJsonCheck'")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
    task.dependsOn("spotlessJsonCheck")
}

tasks.register('test', MetadataTestTask) { task ->
    task.setDescription("Tests JVM Reflection Metadata that matches given coordinates")
    task.coordinates = project.findProperty("coordinates")
}

tasks.register('diff', DiffMetadataTestTask) { task ->
    task.setDescription("Tests JVM Reflection Metadata that was changed between 'baseCommit' and 'newCommit'")
    task.baseCommit = project.findProperty("baseCommit")
    task.newCommit = project.findProperty("newCommit")
}

tasks.register('package', Zip) { task ->
    task.setDescription("Packages current repository to 'build/repository.zip'")
    task.setGroup(PublishingPlugin.PUBLISH_TASK_GROUP)
    task.archiveFileName = "repository.zip"
    task.destinationDirectory = layout.buildDirectory
    from(layout.projectDirectory.dir("metadata"))
}
